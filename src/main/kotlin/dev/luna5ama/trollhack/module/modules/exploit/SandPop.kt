package dev.luna5ama.trollhack.module.modules.exploit

import dev.fastmc.common.floorToInt
import dev.luna5ama.trollhack.event.SafeClientEvent
import dev.luna5ama.trollhack.event.events.render.Render3DEvent
import dev.luna5ama.trollhack.event.safeListener
import dev.luna5ama.trollhack.graphics.ESPRenderer
import dev.luna5ama.trollhack.graphics.color.ColorRGB
import dev.luna5ama.trollhack.gui.hudgui.elements.client.Notification
import dev.luna5ama.trollhack.manager.managers.CombatManager
import dev.luna5ama.trollhack.manager.managers.HotbarSwitchManager.ghostSwitch
import dev.luna5ama.trollhack.module.Category
import dev.luna5ama.trollhack.module.Module
import dev.luna5ama.trollhack.util.inventory.block
import dev.luna5ama.trollhack.util.inventory.slot.allSlotsPrioritized
import dev.luna5ama.trollhack.util.inventory.slot.firstBlock
import dev.luna5ama.trollhack.util.inventory.slot.firstByStack
import dev.luna5ama.trollhack.util.text.NoSpamMessage
import dev.luna5ama.trollhack.util.threads.runSafe
import dev.luna5ama.trollhack.util.world.PlacementSearchOption
import dev.luna5ama.trollhack.util.world.getPlacementSequence
import dev.luna5ama.trollhack.util.world.placeBlock
import net.minecraft.block.BlockFalling
import net.minecraft.init.Blocks
import net.minecraft.util.math.AxisAlignedBB
import net.minecraft.util.math.BlockPos
import kotlin.concurrent.thread

internal object SandPop : Module(
    name = "AutoSand",
    category = Category.EXPLOIT,
    description = "Pop people out of hole using sand"
) {
    private val autoDisable by setting("Auto Disable", true)
    private val render by setting("Render", true)
    private val renderColor by setting("Render Color", ColorRGB(255, 255, 255))
    private val checkFeet by setting("Check Feet Blocks", true)

    private val renderer = ESPRenderer().apply {
        aFilled = 31
        aOutline = 233
    }

    private var sandPos: BlockPos? = null
    private var running = false

    init {
        onEnable {
            running = true
            thread {
                while (running) {
                    runSafe {
                        val target = CombatManager.target ?: run {
                            NoSpamMessage.sendError("$chatName No target found")
                            return@runSafe
                        }

                        val obsidianSlot = player.allSlotsPrioritized.firstBlock(Blocks.OBSIDIAN) ?: run {
                            NoSpamMessage.sendError("$chatName No obsidian found")
                            return@runSafe
                        }

                        val sandSlot = player.allSlotsPrioritized.firstByStack {
                            val block = it.item.block
                            block is BlockFalling
                        } ?: run {
                            NoSpamMessage.sendError("$chatName No sand or concrete powder found")
                            return@runSafe
                        }

                        // Check for redstone torch, rail, or skull at target's feet if enabled
                        val shouldPlaceTwice = if (checkFeet) {
                            val feetPos = BlockPos(target.posX, target.posY, target.posZ)
                            val blockState = world.getBlockState(feetPos)
                            val block = blockState.block

                            block == Blocks.REDSTONE_TORCH ||
                                    block == Blocks.RAIL ||
                                    block == Blocks.SKULL
                        } else false

                        if (shouldPlaceTwice) {
                            Notification.send(SandPop, "Target has triggering block at feet, placing twice")
                        }

                        val abovePos = BlockPos(target.posX, target.entityBoundingBox.maxY + 1.0, target.posZ)
                        sandPos = abovePos

                        val sequence = getPlacementSequence(
                            abovePos,
                            5,
                            PlacementSearchOption.range(5.0),
                            PlacementSearchOption.ENTITY_COLLISION
                        ) ?: run {
                            NoSpamMessage.sendError("$chatName No valid placement found")
                            return@runSafe
                        }

                        for (placeInfo in sequence) {
                            val slot = if (placeInfo.placedPos == abovePos) sandSlot else obsidianSlot
                            ghostSwitch(slot) {
                                placeBlock(placeInfo)
                            }

                            // Place twice if needed
                            if (shouldPlaceTwice && placeInfo.placedPos == abovePos) {
                                ghostSwitch(slot) {
                                    placeBlock(placeInfo)
                                }
                            }
                        }

                        if (autoDisable) {
                            Thread.sleep(1000)
                            disable()
                            return@runSafe
                        }
                    }

                    Thread.sleep(1000)
                }
            }
        }

        onDisable {
            running = false
            sandPos = null
        }

        safeListener<Render3DEvent> {
            if (render) {
                sandPos?.let { pos ->
                    val box = AxisAlignedBB(pos)
                    renderer.add(box, renderColor)
                    renderer.render(true)
                }
            }
        }
    }
}